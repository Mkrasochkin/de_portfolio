/*Добавьте в этот файл пояснения к выбранной модели данных. 
Также вы можете сохранить здесь другие комментарии по проекту, которые вы считаете необходимыми, 
и задать вопросы ревьюеру*/




строка 36.  CREATE TABLE car_shop.gasoline_consumption ( 
В целом потребление это просто число, поэтому его можно хранить прямо в таблице моделей.

мой комментарий:
Да, понял. Занес его в таблицу models.



строка 38. 	consumption numeric(2, 1) /*расход не может быть трёхзначным*/ 
Нужно поправить тип. В нумерик(2,1) максимум поместится число 9.9
Первая цифра в определении типа указывает на количество символов в числе, вторая цифра на количество символов после запятой.

мой комментарий: 
Значит немного не понял этот тип данных. Загуглил этот вопрос в инете, читаю: "precision указывает на максимальное количество цифр, которые может хранить число." 
В проекте максимальный расход 12. Я подумал, что этот расход тоже как и все другие меньшие расходы является двухзначным числом, а поэтому и прописал в параметре precision  - 2.
А, вообще, исправил на varchar, как и в сырых данных - ведь там есть null, а значит думаю числовой тип данных здесь не подходит. Надеюсь правильно теперь.



строка 63. ); 
Нужно поправить схему данных немного.

мой комментарий:
поправил таблицу car_shop.sales_cs. Надеюсь правильно теперь.



строка 84. select distinct gasoline_consumption from raw_data.sales; 
Вот этот запрос у меня тоже упал, потому что в сырых данных у тебя строковый тип, а в нормализованной таблице числовой, по умолчанию он не сможет вставить данные, нужно кастовать к числу.

мой комментарий:
Удалил это таблицу вообще. Ведь как писалось выше, расход топлива добавил в таблицу моделей.




строка 124.	count(*) * 100/1000 ::real as nulls_percentage_gasoline_consumption 
Если у нас будет больше строк в исходной таблице результат будет не корректный.
Нужно вместо хардкода 1000 подставить запрос, который посчитает общее число строк в таблице.

мой комментарий:
Поправил. Надеюсь правильно теперь.



строка 136. ROUND(AVG(price - (price * discount_id) / 100), 2)  as price_avg 
Во втором и третьем задании не нужно цену пересчитывать.

мой комментарий:
Поправил во 2 и 3 заданиях. Надеюсь правильно теперь.



строка 173. MAX(price) as price_max, 
А вот тут нужно цену пересчитать.
Нам нужно получить цену без скидки. Для этого нужно поделить цену со скидкой на долю, которую она составляет от исходной цены.

мой комментарий:
Поправил. Надеюсь правильно теперь.


